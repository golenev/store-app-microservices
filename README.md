# Store App Microservices
Данный учебный проект был написан благодаря пройденным курсам по тестированию Spring приложений на QA.GURU, 
частным консультациям у ментора https://github.com/Alexandr056 , а также ChatGPT 5.

Учебный проект демонстрирует работу цепочки из двух Spring Boot‑микросервисов: **cart-service** отвечает за каталог, авторизацию и
оформление заказов, а **tariffs-service** рассчитывает наценку на основе тарифов. Поставка товара имитируется логистической
службой, отправляющей сообщения в Kafka. При приёмке товара cart-service синхронно запрашивает тарифы, применяет коэффициент
надбавки и сохраняет итоговую цену в PostgreSQL. Чтобы не перегружать tariffs-service, рассчитанные тарифы кешируются в Redis и
сбрасываются по cron‑задаче или ручным вызовом API.

По E2E сценарию логистическая служба привозит на склад набор продуктов(сообщение через Kafka), при приёме товара на баланс,
сервис корзины обращается в сервис цен за получением коэффициента добавочной стоимости в зависимости от типа товара,
его исходной цены, города. Поскольку предполагается, что магазинов тысячи или даже десятки тысяч - тарифы добавочной
стоимости хранятся в кэше(Redis) для экономии запросов в базу. Кэш обновляется по крону раз в сутки. После получения
коэффициента надбавки она суммируется с исходной стоимостью и товар отображается на баланса и его можно "купить",
положив в корзину. Покупка осуществляется через оформление заказа для товаров лежащих в корзине.

## Бизнес-логика
- **tariffs-service** хранит и предоставляет коэффициенты наценки для разных типов товаров. Первый запрос к сервису рассчитывает их из базы и кеширует в Redis, последующие обращения берут данные из кэша.
- **cart-service** принимает сообщения о товарах из Kafka, сохраняет их в PostgreSQL и даёт пользователю API для авторизации, просмотра каталога и работы с корзиной. Перед сохранением товара сервис запрашивает тарифы и применяет наценку.
- **логистическая служба** эмулируется отправкой сообщений в Kafka: поставка товара на склад инициирует начисление наценки через tariffs-service. Кэширование тарифов в Redis избавляет от обращения к базе при каждом сканировании штрихкода.

## Используемые технологии
- **Spring Boot 3 (Java 21)** – основа микросервисов, REST API, безопасность (Spring Security) и валидация.
- **Spring Data JPA + PostgreSQL** – хранение данных каталога и заказов.
- **Spring Kafka + Apache Kafka** – обмен сообщениями между логистикой и корзиной.
- **Redis** – кэш тарифов и ускорение запросов тарифа.
- **Docker Compose** – инфраструктурные зависимости (PostgreSQL, Kafka, Redis, Kafdrop, Redpanda Console).
- **Testcontainers** – подъём временных PostgreSQL, Kafka и Redis в интеграционных тестах.
- **WireMock** – изолированная эмуляция tariffs-service во время тестов cart-service.
- **JUnit 5, Mockito, Rest Assured, Awaitility** – тестирование Java‑модулей.
- **Kotlin + Gradle, Kotest, Allure** – e2e‑сценарии и отчётность.

## Запуск
1. Клонируйте репозиторий
   ```bash
   git clone <repo-url>
   ```
2. Поднимите окружение
   ```bash
   docker-compose up -d
   ```
3. Запустите приложение
   ```bash
   mvn spring-boot:run
   ```
4. Откройте [http://localhost:6789/login.html](http://localhost:6789/login.html) и авторизуйтесь.
   Пользователь по умолчанию: `user` / `qwerty`.

## Основные возможности
- **POST `/api/v1/sendToKafka`** — отправка описания товара в Kafka.
  ```bash
  curl -X POST \
    -H "Content-Type: application/json" \
    -d '{"barcodeId":123,"shortName":"Чай","description":"Чёрный чай","price":55,"quantity":10,"addedAtTariffs":"2024-01-01T12:00","isFoodstuff":true}' \
    http://localhost:6789/api/v1/sendToKafka
  ```
- **GET `/api/v1/products`** — список товаров из базы данных.
- **POST `/api/cart`** — добавить товар в корзину (тело запроса `{ "barcodeId": 123 }`).
- **GET `/api/cart`** — содержимое корзины.
- **DELETE `/api/cart/clear`** — очистить корзину.

Сообщения, отправленные в `send-topic`, автоматически сохраняются в базу и доступны через `/api/v1/products` и веб-страницу `products.html`.

Остановить инфраструктуру можно командой `docker-compose down`.

## Тесты
- `cart-service/src/test/java/unit` — юнит‑тесты бизнес-логики корзины: проверяют расчёт тарифов, определение типа товара и получение
  продукта из репозитория с помощью JUnit 5 и Mockito.
- `cart-service/src/test/java/stageTests` — интеграционный сценарий ProductFlowTest поднимает PostgreSQL, Kafka и WireMock через
  Testcontainers, прогоняет end-to-end процесс добавления товара и проверяет ограничения корзины.
- `tariffs-service/src/test/java/com/tariffs/TariffServiceCacheTest.java` — интеграционные тесты сервиса тарифов с Testcontainers
  для PostgreSQL и Redis: убеждаемся, что первый запрос идёт в базу, а повторный — в кэш, и что сброс очищает кэш.
- `e2e-tests/src/test/kotlin/stageTests` — внешние end-to-end тесты на Kotlin (Kotest + Rest Assured), покрывающие API тарифов,
  обработку Kafka и оформление заказа; результаты публикуются в Allure-отчёте.

## E2E тесты и Allure Report
Тесты написаны на Kotlin с использованием JUnit 5, Kotest и Rest Assured; для отчётности подключён [Allure](https://github.com/allure-framework/allure2).
Чтобы запустить e2e-тесты и сгенерировать отчёт, выполните:
```bash
cd e2e-tests
./gradlew test
./gradlew allureReport
```
Готовый отчёт будет доступен в каталоге `e2e-tests/build/reports/allure-report/index.html`.
Для интерактивного просмотра можно использовать команду `./gradlew allureServe`.
